Para a implementação do interpretador, as tarefas necessárias para a interpretagção, do código fonte ao resultado final de uma computação, foram divididas entre três módulos: o Leitor, o Compilador e a Máquina Virtual.

O Leitor, um elemento tradicional na implementação de linguagens da família Lisp, é responsável por traduzir o código em formato textual fornecido pelo usuário em uma estrutura de listas e átomos conhecida como Expressões Simbólicas (ou S-Expressions, como são usualmente conhecidas na literatura). Durante a fase de leitura é realizada a análise léxica, bem como a formação das listas que compõe a estrutura de um programa Scheme, que corresponde a parte da análise sintática. Uma descrição mais detalhada da implementação do Leitor é dada na seção ${reader-section}.

O Compilador, de posse das S-Expressions geradas pelo Leitor, identifica qual estrutura da linguagem cada S-Expression representa, reconhece instâncias de macros que devem ser traduzidas para as definições dadas pelo usuário e finalmente gera o código que deve ser executado para avaliação das expressões fornecidas. Como a tradução de macros acontece antes da geração de código, esta fase fica significativamente mais simples, precisando apenas lidar com as poucas estruturas primitivas que a linguagem define, deixando as demais para serem reduzidas às estruturas primitivas por meio de macros. Na seção ${compiler-section} são fornecidos mais detalhes sobre o Compilador.

Por fim, a Máquina Virtual é encarregada de avaliar as operações codificadas em instruções básicas, utilizando o código gerado pelo compilador, e retornar o valor desta avaliação. Para tanto, esta depende de um contexto de execução, composto das ligações presentes no escopo global. Informações extras de contexto, como os escopos locais e estado da pilha de controle, entre outras, são mantidas e serão discutidas, junto com uma descrição detalhada da Máquina Virtual, na seção ${virtual-machine-section}.

Uma representação simplificada do interpretador, então, pode ser feita como na figura ${visao-geral-implementacao.png}.

Os três módulos descritos acima não são suficientes para a completa interpretação do código, sendo necessários dois outros módulos auxiliares: o Sistema de Tradução de Macros, que é utilizado pelo compilador para traduzir as S-Expressions de expressões derivadas em composições de S-Expressions de expressões primitivas, e o Sistema de Gerência de Memória, que é responsável por alocar e desalocar memória para todos os outros módulos do interpretador.

O Sistema de Tradução de Macros é uma implementação similar às macros tradicionais de Lisp [Graham 1996], conhecidas como "estilo defmacro", em que o mecanismo utilizado é a execução de código arbitrário definido pelo usuário, sem informações extra de escopo léxico, manipulando expressões somente como listas. Esta estratégia possui diversos problemas que serão discutidos na seção ${macro-section}, além de uma discussão sobre as mudanças necessárias para a implementação de um sistema de macros como o descrito no R7RS.

Todos os módulos descritos acima são implementados sobre o sistema de Gerência de Memória. A Gerência de Memória é baseada em uma implementação simples do algoritmo de Mark & Sweep [Richard Jones & Lins 1996], em que a memória livre é armazenada como uma lista encadeada de nós de memória de tamanho único (neste caso, 12 bytes). Uma descrição detalhada do sistema de Gerência de Memória depende de um conhecimento maior sobre a arquitetura da máquina virtual para identificar as raízes de busca por nós ativos, e será deixada para a seção ${garbage-collection-section}
