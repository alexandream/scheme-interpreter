- 1: Visão Geral do Trabalho.

Apresentaremos, neste e nos próximos capítulos, uma implementação de referência, e as técnicas utilizadas nesta, da mais recente edição do relatório que padroniza a linguagem de programação Scheme (R7RS), atualmente em processo de ratificação. 

Scheme é uma linguagem de programação da família Lisp, minimalista e multi-paradigma, embora com um grande foco em programação funcional. Como um dialeto Lisp, difere significativa dos demais dialetos mais conhecidos da família (Common Lisp e Emacs Lisp) por características como: modelo de escopo totalmente léxico, continuações como objetos de primeira classe e espaço de nomes compartilhado entre funções e variáveis. Também se destaca por ser tradicionalmente minimalista, preferindo primitivas poderosas e altamente ortogonais, que podem ser compostas de modo a criar novas expressões, a funcionalidades especializadas[1]. 

Estas características tornam Scheme especialmente apropriada para o ensino de conceitos de linguagens de programação e computação, assim como a facilidade de implementar novos conceitos e funcionalidades sobre a linguagem a tornam uma boa base para o estudo exploratório de novos conceitos de linguagens de programação. Isto é evidenciado pela profusão de cursos iniciais de computação e programação que adotam Scheme como linguagem, inclusive em cursos de nível médio[2][3][6], bem como diversas publicações na área de projeto de linguagens de programação e design de interpretadores baseados em Scheme[4][5].

O foco dado em minimalismo aliado à utilização comum de Scheme como uma linguagem base para o estudo de linguagens de programação e suas implementações contribuíram para que, de forma tácita, as evoluções da linguagem da década de 1970 até a publicação da quinta revisão (R5RS)[7] em 1998 fossem norteadas pela possibilidade de a linguagem ser implementada tanto de forma eficiente e sofisticada, quanto por um aluno com conhecimentos de um curso de graduação em compiladores.

Em 2007 um novo processo de revisão da linguagem foi concluído, dando origem ao relatório R6RS[8]. Este relatório tinha a ambição de criar uma linguagem mais completa e próxima das necessidades de desenvolvimento de aplicações não acadêmicas, o que consequentemente a distanciava significativamente dos objetivos que nortearam o desenvolvimento até o R5RS. Junto com incompatibilidades sérias com a profusão de implementações de Scheme existentes, o relatório R6RS foi largamente ignorado pela comunidade de implementadores, causando grande controvérsia entre a comunidade Scheme ao redor do mundo[9].

Como resultado desta divisão na comunidade, em 2009 iniciou-se um novo esforço para revisão da linguagem, o novo relatório chamado R7RS. Para evitar os problemas anteriores foi decidido que a evolução da linguagem se daria em duas frentes: uma linguagem "pequena" (posteriormente nomeada simplesmente R7RS-small), guiada pelos princípios de minimalismo que historicamente foram seguidos, e uma linguagem "grande" (R7RS-large), baseada na R7RS-small[10]. 

O processo de ratificação da R7RS-small está próximo do fim, com o draft mais recente tendo sido publicado em março de 2011[11], enquanto a linguagem R7RS-large foi deixada para definição futura pelo fato de todos os participantes do grupo de trabalho dedicado à R7RS-large também fazerem parte do grupo de trabalho dedicado à R7RS-small e preferirem terminar o trabalho de base antes de iniciar o trabalho mais completo nas camadas acima.

Este trabalho é uma tentativa de demonstrar a aderência aos princípios de minimalismo e capacidade de implementação de Scheme como objeto de estudo de alunos de graduação em ciência da computação por meio da apresentação de uma implementação, e das técnicas envolvidas nesta, da linguagem como descrita até o momento pelo terceiro draft. Deste ponto em diante, utilizamos os termos "Scheme" e "R7RS-small" intercambiavelmente, exceto quando explicitamente informarmos o contrário.

No próximo capítulo discutiremos a linguagem Scheme e suas funcionalidades mais notáveis, que a diferenciam da maior parte das linguagens de uso geral em amplo uso atualmente. Também discutiremos outras implementações da linguagem R7RS-small em andamento atualmente, e suas diferenças em relação a este trabalho.

A seguir, no capítulo 3, discutimos a implementação que é o foco deste trabalho, detalhando a estratégia utilizada e descrevendo os mecanismos e técnicas utilizadas para gerência de memória, ambiente de execução e compilador. Apresentamos também os pontos em que a abordagem inicialmente proposta (e implementada) não é suficiente para expressar a linguagem Scheme e então detalhamos estratégias alternativas que podem ser utilizadas para estender a implementação atual para ser capaz de transpor estes problemas.

# TODO [1]: Nos capítulos 4 e 5 eu ainda não sei o que eu vou falar ;)


- 2 : Sobre Scheme e outras implementações.

Como mencionamos anteriormente, a linguagem Scheme mantém características de minimalismo e simplicidade conceitual que a tornaram bastante populares como ambiente de estudo de conceitos e implementações de linguagens de programação além de ser utilizada em diversas instituições de ensino como linguagem inicial para aprendizado de conceitos de computação e programação.

Curiosamente praticamente todas estas características são meros acidentes no processo de desenvolvimento da linguagem. O objetivo inicial do desenvolvimento, por Gerald Jay Sussman e Guy L. Steele Jr, foi criar um dialeto Lisp simples para mapear e melhor compreender o modelo de computação chamado "Actor Model", proposto por Carl Hewitt. Esta implementação, publicada ao longo de diversos memorandos entre 1975 e 1980, resultou na linguagem de programação Scheme.[1]

Como resultado deste empreendimento, Sussman e Steele acabaram por descobrir que o modelo proposto por Hewitt podia ser diretamente traduzido para o modelo de computação já bastante conhecido à época chamada Cálculo Lambda, do qual as linguagens da família Lisp já se aproximavam muito, e que um dialeto Lisp poderia ser criado para representar o Actor Model bastando que os modelos de computação utilizados para Lisp na época fossem estendidos com um mecanismo de escopo léxico (em contraste com o escopo dinâmico utilizado por todos os dialetos Lisp da época) e o conceito de Continuações, que discutiremos em breve, fosse exposto como objetos de primeira classe.

Em especial, o modelo de escopo dinâmico utilizado nos dialetos Lisp até então fazia com que a família Lisp divergisse consideravelmente do Cálculo Lambda por seu tratamento de variáveis livres. A adoção do escopo léxico por Scheme criou na família Lisp uma linguagem compatível com um subconjunto significativo do formalismo descrito no Cálculo Lambda e uma ótima plataforma para expressar e analisar conseqüências de modelos descritos no Cálculo Lambda.[1]

A seguir, é descrito um subconjunto das funcionalidades de Scheme de forma a familiarizar o leitor com a linguagem e facilitar a compreensão da subsequente discussão de sua implementação e as estratégias utilizadas.

-- 2.1: Descrição da linguagem e suas funcionalidades. 

Variáveis em Scheme não possuem tipo. O tipo é uma propriedade do valor armazenado na variável, com a checagem dos tipos feita em tempo de execução, não havendo verificação estática desta característica. A linguagem vem equipada com um conjunto modesto de tipos e permite ao programador criar seus próprios tipos disjuntos dos tipos existentes.

Não existe em Scheme, também, o conceito de classes, como em linguagens orientadas a objeto, embora este conceito tenha sido diversas vezes implementado em termos das primitivas da linguagem [12][13][14]

O Minimalismo de Scheme pode ser verificado na forma como primitivas comuns em outras linguagens se mostram ausentes, sendo substituídas por construções compostas de primitivas mais abrangentes. Por exemplo, no lugar de expressões de retorno, mecanismos de exceções e interrupções de estruturas de laço (como /break/ e /continue/), temos apenas as primitivas de obter a continuação atual e aplicar uma continuação. Até mesmo as estruturas de laço, mencionadas há pouco, não são primitivas em Scheme: são meros padrões de utilização das primitivas de criar uma nova função e aplicação de funções.

Para que esta utilização de funções como estruturas de laço, utilizando recursão, não esgote a memória de uma implementação arbitrária (por exemplo, esgotando a pilha utilizada para manter a cadeia de chamadas), qualquer implementação Scheme é obrigada a realizar a eliminação dos registros de ativação de chamadas terminais (/tail-calls/): aplicações de função nas quais o resultado da função chamada será, também, o resultado da função chamadora. Como exemplo, observemos a execução de uma função simples, que retorna a soma de dois números naturais utilizando apenas as operações de incremento e decremento, com e sem eliminação de chamadas terminais.

    (define (add op1 op2)
      (if (zero? op1)
        op2
        (add (dec op1) (inc op2))))

Esta função é obviamente recursiva, mas a chamada recursiva aparece em uma posição terminal. Na figura ${fig:tail-call-elimination} vemos como seria o consumo de memória utilizado para armazenar os registros de ativação em duas implementações hipotéticas com e sem eliminação de chamadas terminais.

{$do-fig:tail-call-elimination}

Quando uma implementação Scheme se depara com uma aplicação de chamada de função terminal, esta, obrigatoriamente, deve evitar criar um novo registro de ativação e reutilizar o registro de ativação da função em vigor como o registro de ativação da função prestes a ser chamada. Desta forma, recursões em que a chamada recursiva em si é considerada terminal utilizam quantidade constante de memória na pilha de ativações de funções.

Como membro da família Lisp, código Scheme é representado textualmente por listas de elementos separados por espaço em branco, agrupados por parênteses, que denotam um formato abstrato conhecido como Expressões-S (abreviação de Expressões Simbólicas). Expressões-S podem ser definidas recursivamente da seguinte forma:
 - Um elemento atômico (número, símbolo ou outro literal da linguagem) é uma Expressão-S;
 - Uma lista de Expressões-S é uma Expressão-S;

Ainda em conformidade com a família Lisp, Scheme adota a notação polonesa (ou notação de prefixos), com as listas representando operações em que o primeiro elemento da lista é o operador, que pode ser uma função ou uma forma sintática, e os demais elementos são parâmetros para a operação. A distinção entre funções e formas sintáticas pode ser traçada com base na fase da computação em que são avaliados e na estratégia de avaliação de parâmetros, como visto na tabela ${table:functions-vs-special-forms}.

# TODO[3]: Criar a tabela abaixo.
${do-table:function-vs-special-forms}

Scheme herda dos Lisps anteriores um grande número de operações sobre listas, e a utilização de Expressões-S (estruturas baseadas em listas) faz com que seja fácil manipular representações em Expressão-S de código Scheme, utilizando a própria linguagem. Esta propriedade, aliada à capacidade do programador de definir código de funções ou substituições a serem aplicadas no código anteriormente à compilação ou interpretação, leva a um poderoso sistema de macros que permite ao programador criar novas formas sintáticas que são convertidas para formas primitivas da linguagem. Desta maneira, o fato de ser uma linguagem minimalista não interfere com a expressividade do programador final, que em geral lida com expressões mais complexas abstraídas por trás de formas sintáticas derivadas.

Como mencionado anteriormente, Scheme foge da tradição entre linguagens anteriores da família Lisp por adotar um modelo de escopo léxico, estático, em que o escopo de uma variável pode sempre ser determinado pela simples análise do texto do programa. Partindo do ponto em que a variável é referenciada, utilizando escopo léxico, e voltando na estrutura do código é sempre possível encontrar o ponto em que esta é declarada ou, caso não seja possível (ou seja, esta variável é uma variável livre no contexto atual), esta tem de ser uma variável global -- ou um erro por parte do programador, visto que então a variável não estaria declarada em lugar algum.

Tradicionalmente, no entanto, dialetos Lisp implementavam uma estratégia de escopo dinâmico em que uma variável livre estava vinculada à declaração da mais recente variável de mesmo nome no contexto dinâmico da pilha de chamadas anteriores. A diferença entre as estratégias de escopo léxico e dinâmico pode ser analisada na figura ${fig:dynamic-vs-lexical-scope}. 

A mudança para o escopo léxico, associada à possibilidade de criação e manipulação de funções como objetos em tempo de execução, faz com que seja possível gerar /closures/, ou seja: pequenas funções que capturam o vínculo de variáveis como estavam no momento em que a função foi declarada em tempo de execução e carregam estes vínculos consigo, podendo manipulá-los e modificá-los como quiser. 

# TODO [4]: Criar a figura abaixo.
${do-fig: dynamic-vs-lexical-scope}

A utilização do escopo léxico em Scheme, de acordo com os seus criadores [1], fez com que o tratamento de variáveis livres em um a expressão fosse semanticamente análogo ao dado no formalismo do Cálculo Lambda, fornecendo um bom modelo computacional para experimentação com o Cálculo Lambda. Novamente de acordo com os criadores da linguagem [1], esta proximidade com o Cálculo Lambda foi um dos motivos principais para a utilização futura, não prevista originalmente, de Scheme como uma linguagem de ensino e experimentação de conceitos de linguagens de programação.

# TODO [5]: Escrever mais coisas aqui.

-- 2.2: Outras implementações e trabalhos relacionados.

Até o momento da conclusão deste trabalho, apenas duas outras tentativas de implementar o conteúdo dos drafts da R7RS-small foram encontradas: chibi-scheme, criada pelo presidente do grupo de trabalho responsável pelo R7RS-small[15]; e r7rs-bridge criada por OKUMURA Yuki[16].

Os objetivos destas, no entanto, diferem significativamente deste trabalho:

Chibi Scheme é uma tentativa de implementar a linguagem R7RS-small (além de alguns dialetos mais antigos como o R5RS) como uma biblioteca de extensão e linguagem de script para programas em C. Seu foco principal está em diminuir o tamanho do executável final e aumentar a performance. Embora o código seja relativamente bem comentado, não há qualquer intenção de escolher funcionalidades e estratégias pensando na simplicidade de implementação em detrimento dos objetivos citados acima. Desta forma, Chibi Scheme não é uma implementação viável para demonstração da capacidade de se implementar a linguagem R7RS-small como objeto de estudo.

R7RS-Bridge, de fato, é uma tentativa completamente diferente, focada em desenvolver uma linguagem compatível com R7RS-small através de bibliotecas para sistemas Scheme R6RS. Este pré-requisito em ter uma implementação anterior do R6RS, o relatório considerado complicado demais pela comunidade Scheme, claramente coloca as intenções de R7RS-Bridge distantes de uma implementação de R7RS-small como objeto de estudo.


- 3: Estrutura Geral da Implementação, Estratégias Utilizadas.

Para a implementação do interpretador, as tarefas necessárias para a interpretagção, do código fonte ao resultado final de uma computação, foram divididas entre quatro módulos: o Leitor, o Compilador, a Máquina Virtual e o Sistema de Gerência de Memória.


O Leitor é responsável pela primeira etapa antes da compilação propriamente dita: traduzir o código em formato textual fornecido pelo usuário para Expressões-S. Durante a fase de leitura é realizada a análise léxica, bem como a formação das listas que compõe a estrutura de um programa Scheme, que corresponde a parte da análise sintática. O módulo Leitor é descrito em mais detalhes na seção 3.2.

Utilizando as Expressões-S geradas pelo Leitor, identifica qual estrutura da linguagem cada Expressão-S representa, reconhece instâncias de macros que devem ser traduzidas para as definições dadas pelo usuário e finalmente gera o código que deve ser executado para avaliação das expressões fornecidas. Como a tradução de macros acontece antes da geração de código, esta fase fica significativamente mais simples, precisando apenas lidar com as poucas estruturas primitivas que a linguagem define, deixando as demais para serem reduzidas às estruturas primitivas por meio de macros. Na seção 3.3 são fornecidos mais detalhes sobre o Compilador, bem como seus sub-módulos: o Leitor e o Sistema de Macros.

A Máquina Virtual, então, é encarregada de avaliar as operações codificadas em instruções básicas, utilizando o código gerado pelo compilador, e retornar o valor desta avaliação. Para tanto, esta depende de um contexto de execução, composto das ligações presentes no escopo global. Informações extras de contexto, como os escopos locais e estado da pilha de controle, entre outras, são mantidas e serão discutidas, junto com uma descrição detalhada da Máquina Virtual, na seção 3.4.

Uma representação simplificada do interpretador, então, pode ser feita como na figura ${fig:visao-geral-implementacao}.

${do-fig:visao-geral-implementacao}

Os módulos descritos acima são implementados sobre o sistema de Gerência de Memória. A Gerência de Memória é baseada em uma implementação simples do algoritmo de Mark & Sweep [17], em que a memória livre é armazenada como uma lista encadeada de nós de memória de tamanho único (neste caso, 24 bytes). Com a ajuda de um conhecimento mais íntimo da máquina virtual em questão, o sistema de gerência de memória pode então, quando necessário, identificar quais nós de memória estão em uso e liberar para uso posterior todos os demais. Na seção 3.1 detalharemos o sistema de memória, embora uma compreensão completa do mesmo só seja possível após indicarmos quais partes da máquina virtual estão envolvidas no processo de identificar quais nós de memória estão em uso.

Podemos ter então, quebrando o trabalho do compilador em seus sub módulos separadamente, uma visão geral da arquitetura do Interpretador, em como os módulos se relacionam na figura ${fig:camadas}

${do-fig:camadas}

A implementação do interpretador baseado no esquema descrito acima se dá em um ambiente de duas linguagens: C++ e Scheme.

A estrutura básica do interpretador, até o ponto em que este é capaz de interpretar um pequeno conjunto de operações básicas, é feito em C++. Esta estrutura inclui todo o mecanismo de gerência de memória, o leitor, o compilador para as estruturas sintáticas primitivas e a máquina virtual, além de um pequeno conjunto de funções primitivas que são mais fácilmente implementadas em C++ por apenas delegarem o trabalho para funções e operadores primmitivos desta linguagem.

A partir deste ponto, as demais estruturas sintáticas são escritas na forma de macros em Scheme e diversas funções da biblioteca são implementadas em código Scheme que roda no próprio interpretador. 

Utilizando uma análise de número de linhas de código, que não é exatamente representativa dada a diferença de expressividade das duas linguagens, aproximadamente 88% da implementação é feita em C++, enquanto que os 12% restantes são feitos em Scheme.

-- 3.1 Sistema de Gerência de Memória.

Embora não seja exatamente um requerimento da R7RS-small, escolhemos por implementar um mecanismo de gerência de memória automatizado, o que definiu em diversas formas as escolhas utilizadas para representação dos valores em tempo de execução nesta implementação. Além disso, historicamente Lisp está tão intimamente ligada à gerência automatica de memória[20] que uma implementação que não contemplasse esta faceta não 

Em especial, existem dois tipos de valores, divididos por necessitarem ou não de alocação de memória dinâmica. Entre os valores que não necessitam de alocação de memória dinâmica, que chamaremos daqui em diante de valores imediatos, encontram-se os inteiros, booleanos, caracteres e alguns valores especiais como o marcador de lista vazia. Estes, são implementados na forma de "ponteiros etiquetados" (tagged pointers), em que os dados ocupam os 62 bits mais significativos de uma palavra de 64 bits, e os 2 bits menos significativos são utilizados para identificar os valores como imediatos, identificação preliminar do tipo e diferenciar estes valores dos demais ponteiros no sistema.

Os demais, como funções, strings, pares e quaisquer estruturas de dados complexas, são implementados seguindo uma estrutura de dados comum a todos, de forma a simplificar a implementação do mecanismo de gerência de memória. Nestes, os 2 bits menos significativos têm obrigatóriamente o valor zero, criando a necessidade de um alinhamento de 4 bytes para cada objeto alocado em memória. A estrutura utilizada para estes valores complexos é a descrita a seguir:

Uma palavra de 64 bits é utilizada para manter informações de tipo, dados relacionados à gerência de memória e se o objeto armazenado pode ser modificado. Entre estes, devemos ressaltar os dados de gerência de memória que indicam:

* se o objeto foi visitado pelo sistema de gerência de memória durante a coleta
  (GC_HAS_MARK);

*  se o objeto está em uso pelo sistema (GC_IS_IN_USE);

*  se o mecanismo de gerência de memória deve analisar seu filho esquerdo
   (MARK_POLICY_FIRST) e/ou seu filho direito (MARK_POLICY_SECOND);

*  ou se a memória para este objeto nunca deve ser liberada (GC_ALWAYS_MARKED).

Além destas informações, um conjunto de bits é utilizado para manter a informação sobre o tipo destes objetos, para questões de despacho de funções e checagem de tipos. Oito bits foram utilizados para este fim, embora devido ao grande espaço não utilizado na estrutura mais possam ser utilizados para estender o mecanismo de tipos caso seja necessário.

Em seguida, duas outras palavras de 64 bits são utilizadas para armazenar as demais partes da estrutura de dados. Estas duas palavras (que referenciaremos por "slots") armazenam valores arbitrários do sistema, usando a mesma técnica de tagged pointers mencionada anteriormente, em que valores imediatos são armazenados diretamente e valores complexos são armazenados como ponteiros para outras estruturas idênticas à que estamos descrevendo. 

Tendo em vista que não estamos preocupados em otimização, mas em clareza, esta estrutura simples representa diretamente a estrutura de dados mais utilizada em um dialeto Lisp: a "célula cons" que é utilizada para, entre outras coisas, representar listas. Uma célula cons nada mais é que um par de dois outros valores quaisquer da linguagem.

Todos os demais valores expressos na linguagem, que não possam ser representados por valores imediatos, são representados utilizando esta estrutura de armazenamento duplo em slots. Em alguns casos apenas um dos slots de armazenamento é utilizado, em outros casos ambos. Na figura ${fig:memory} podemos ver alguns exemplos de como a memória é estruturada quando representamos (A) uma string; (B) uma função primitiva; (C) uma lista com um símbolo e alguns valores imediatos.

${do-fig:memory}

Dado que todos os valores armazenados por meio de alocações dinâmicas possuem o mesmo formato e é trivialmente possível identificar ponteiros para outros objetos na estrutura utilizada, fica simples implementar um mecanismo de gerência de memória. O algoritmo utilizado é o mesmo descrito por John McCarthy em sua implementação de Lisp[20], e consiste dos seguintes passos:

* Inicialize a memória como um bloco de elementos "livres", prontos a serem
  utilizados;
 
* Configure este bloco de forma que o segundo slot de cada elemento aponte para o próximo, formando uma lista encadeada de elementos livres;
 
* A cada nova alocação necessária, obtenha um elemento da lista de elementos
  livres;
 
* Quando não houver mais elementos livres, identifique os elementos que estão
  em uso e marque-os (fase de marcação);
 
* Após marcar os elementos em uso, varra a área de memória utilizada retornando
  todos os elementos que não estão sendo utilizados para a lista de elementos
  livres (fase de varredura).

Para identificar os elementos que estão em uso, basta seguir as cadeias de referências dos slots da estrutura descrita acima, a partir dos registradores da máquina virtual e de algumas outras estruturas auxiliares, marcando todos os elementos encontrados como sendo utilizados.

Dado que os elementos são alocados dentro de um ou mais blocos conhecidos de memória, é fácil iterar por todos os elementos alocados, reinserindo-os na lista de elementos livres se não estiverem marcados e desmarcando os que estiverem, para deixar o estado geral da memória pronto para outro ciclo de coleta.

Por questões de otimização uma flag (GC_ALWAYS_MARKED) indica objetos que não são varridos por gerenciarem a própria memória e nunca serem desalocados após serem criados. E por haver valores que não ocupam ambos os slots, ou ainda por haver valores que guardam dados que não são controlados pela gerência de memória nestes slots, algumas flags (MARK_POLICY_FIRST, MARK_POLICY_SECOND) controlam se é necessário continuar o percurso por cada um dos slots de um elemento.

Este modelo simples de gerência de memória, conhecido como Mark & Sweep pelas duuas fases utilizadas[17], é suficiente para garantir que a máquina virtual utilize plenamente toda a memória disponível antes de terminar por falta de memória.



-- 3.2 Leitor

O módulo Leitor, uma parte tradicional da implementação de linguagens da família Lisp é responsável por receber um fluxo de texto e processá-lo para obter um fluxo de Expressões-S.

Sua primeira responsábilidade é a análise léxica da entrada, identificando os tokens no texto e transformando-os em representações de objetos atômicos no contexto das Expressões-S: constantes simbólicas, constantes numéricas e outras constantes além de pontuação como parênteses e ponto, e eliminar os comentários. 

Além da análise léxica, o Leitor vai um passo além, construindo as estruturas (listas) que compõem uma Expressão-S, agrupando os objetos de forma que todo o resto do processo de compilação não precise se preocupar com como a informação é armazenada textualmente, lidando apenas com Expressões-S.

Sua implementação é bastante simples: Utilizando o gerador de analisadores léxicos GNU Flex[18] é criada uma função inicial capaz de traduzir a entrada textual nos respectivos objetos atômicos e pontuação reconhecidos pela estrutura das Expressões-S. Neste ponto, a análise léxica é concluída. 

Uma segunda função, que é exposta para os demais módulos, é responsável por coordenar as chamadas à função gerada pelo GNU Flex e criar as estruturas recursivas de uma Expressão-S, as listas e sublistas.

Todas as estruturas criadas são alocadas com a ajuda do Sistema de Gerência de Memória, e entre uma alocação e outra, são protegidas usando a pilha de proteção de memória, para evitar que uma chamada à coleta de lixo durante a execução de uma chamada ao Leitor descarte memória que foi recentemente alocada mas ainda não está em uso pelo programa do ponto de vista da Máquina Virtual.


-- 3.3 Compilador

A estratégia utilizada para o compilador é derivada de um compilador utilizado como exemplo por Kent Dybvig em sua tese de doutorado[19]. Este compilador, embora simples, sofre de algumas deficiências que serão discutidas adiante.

Durante a etapa de compilação traduzimos uma Expressão-S representando código Scheme para uma Expressão-S representando a implementação deste código nas instruções utilizadas pela máquina virtual. Observe que, como a compilação se dá em termos de Expressões-S como entrada, nada impede que um usuário forneça ao compilador uma Expressão-S que não é diretamente derivada da representação textual do programa. Esta informação será utilizada quando discutirmos o mecanismo de tradução de Macros.

Neste momento vamos abstrair o funcionamento do mecanismo de macros, dizendo apenas que antes de a compilação propriamente dita ter início, o Compilador invoca o sistema de macros para processar a Expressão-S recebida como entrada de forma a transformá-la em uma Expressão-S representando uma das poucas operações primitivas das quais o compilador tem conhecimento. Este fato simplifica muito a etapa de compilação, permitindo ao compilador se preocupar apenas com um número reduzido das estruturas sintáticas definidas no R7RS-small.
A estratégia de implementação utilizada é a mais ingênua possível. Com efeito, esta implementação não mantém informações de análise estática relacionadas a escopo, o que a faz incapaz de representar o mecanismo de macros definido pela linguagem Scheme. A implementação de um mecanismo alternativo de macros procedurais, compatível com os mecanismos tradicionais de outras linguagens da família Lisp, além de uma descrição das mudanças necessárias para se implementar o mecanismo de macros descrito por Scheme, são discutidos posteriormente na seção ${COMPILER-MACROS}.

Dez tipos de expressão são reconhecidos pelo compilador: Referência a variável, constantes,  expressões literais, criação de procedimentos, condicionais, atribuições, definições, definições de macro, obtenção de continuação e aplicação de função. A partir destes tipos primitivos de expressão, com a ajuda do mecanismo de macros, todas as outras estruturas sintáticas da linguagem são construídas, simplificando significativamente o projeto do compilador.

O processo de compilação inicia-se com dois parâmetros: a expressão a ser compilada e a próxima etapa da computação que está sendo efetuada. Quando estamos realizando a compilação de uma expressão no escopo mais alto, esta próxima etapa normalmente é um pedaço de código pré compilado correspondendo à instrução Halt da máquina virtual. Esta expressão representando a próxima etapa da computação pode então ser utilizada para compor o parâmetro das instruções da máquina virtual que indica qual a próxima instrução a ser executada.

# TODO [7]: Terminar esta seção.

-- 3.4 Máquina Virtual

A máquina virtual utilizada é baseada na arquitetura de máquina virtual SECD descrita por Peter Landin [Landin 1964] com pequenas alterações nos registradores e instruções propostas por Kent Dybvig em sua tese de doutorado[19]. Esta, como a de Landin, utiliza uma estrutura baseada em pilha, com um pequeno número de registradores que apontam para memória organizada em listas encadeadas. 

A estrutura da máquina é bastante simples: cinco registradores e 14 instruções. Os registradores são todos baseados em memória organizada como listas, enquanto que as instruções todas compartilham uma peculiaridade: Recebem como parâmetro o código que deverá ser executado ao fim da instrução em questão. As duas exceções óbvias são as instruções _HALT_, que termina a operação da máquina e obviamente não recebe código algum para continuar, e _TEST_, que decide entre duas linhas diferentes e portanto recebe dois parâmetros de código para escolher executar ao fim da mesma.

Esta propriedade de representar o fluxo de controle de instruções explícitamente na forma de parâmetros para todas as instruções simplifica significativamente a implementação de duas das mais complexas funcionalidades da linguagem: A obrigatoriedade de eliminar as chamadas terminais e a criação e aplicação de continuações em tempo de execução.

Levando-se em consideração a simplicidade do código necessário para se implementar a máquina virtual SECD (aproximadamente 350 linhas de código em C++) e o fato de ela tornar trivial a implementação das duas funcionalidades mais complexas, esta foi escolhida para a implementação da fase de interpretação propriamente dita neste interpretador. A seguir descrevemos em detalhes os registradores e instruções que compõem esta máquina.

-- 3.4.1 Registradores

O estado interno da máquina é composto pelos seus cinco registradores: os quatro originais descritos por Landin, que dão o nome à máquina (Stack, Environment, Code e Dump), acrescidos de um Acumulador.

- O registrador Stack, que aponta para uma lista encadeada que armazena temporariamente os valores intermediários que serão ser passados para chamadas de funções como parâmetros. 

- Na arquitetura original não havia a presença de um Acumulador, que foi utilizado apenas para simplificar a codificação de algumas etapas, e poderia perfeitamente ser substituído pelo uso judicioso do topo da pilha para esta função. Este serve apenas para guardar resultados intermediários de forma separada da pilha de parâmetros guardada na Stack.

- O registrador Environment aponta para uma lista composta dos níveis de vínculos de variáveis válidos no escopo atual, estendendo-se até que o escopo global é atingido por último.

- O registrador Code aponta para uma representação da próxima instrução a ser executada e pode ser visto como um análogo ao _contador de programa_ em uma arquitetura convencional de hardware, com a diferença que, no modelo utilizado neste trabalho, cada instrução carrega consigo uma referência explícita para a próxima instrução a ser executada, ao invés de depender de um incremento implícito de contador.

- O registrador Dump mantém uma área de armazenamento temporário para todos os outros registradores, composto de um conjunto (A, S, E, C, D) que, tendo como elemento o conteúdo anterior do registrador Dump, mantém uma pilha de contextos. É internamente utilizado para manter a pilha de registros de ativação de chamadas de função.

-- 3.4.2 Instruções
# TODO [9]: Criar as figuras 
Para atuar sobre o estado interno da máquina, utilizamos 14 instruções que são descritas a seguir. Na verdade, apenas 13 instruções seriam necessárias para implementar a arquitetura proposta neste trabalho mas, devido a um problema de projeto na fase do compilador uma instrução extra foi incluída de forma que a máquina virtual possui algum conhecimento sobre o sistema de macros.

A instrução _TEST_ (${fig:op_test}) realiza controle de fluxo condicional, utilizando o valor armazenado no acumulador e dois parâmetros chamados "conseqüência" e "alternativa". Ambos os parâmetros representam trechos de código.

${do-fig:op-test}

De acordo com o valor armazenado no Acumulador, decide se deve continuar a execução pela _consequência_ (caso este valor seja diferente do literal _false_) ou pela _alternativa_ (caso este seja igual ao literal _false_), armazenando no registrador Code o valor escolhido entre os dois parâmetros.

${do-fig:op_test}

A instrução _FRAME_ (${fig:op_frame}) é utilizada para salvar o estado da máquina quando se faz necessária a execução de um outro procedimento, armazenando o valor dos registradores atuais em uma pilha. Recebe dois parâmetros: _retorno_, que indica o código que deve ser executado quando este frame for restaurado, e _próximo_, que indica o código a ser executado ao fim desta instrução.

${do-fig:op_frame}

Um novo frame é armazenado no registrador Dump, contendo o valor dos registradores Environment, Stack e Dump, junto o valor do parâmetro _retorno_ que atua como valor do registrador Code. Então o valor do registrador Stack é setado para uma lista vazia e o valor do registrador Code é setado como o valor recebido no parâmetro _próximo_.

A separação entre a instrução _FRAME_ e a instrução _APPLY_, utilizada para invocar uma chamada de função, é crucial para a implementação da eliminação de chamadas terminais: quando o compilador identifica que uma chamada é terminal, simplesmente omite a criação de uma instrução _FRAME_.

A instrução _CONSTANT_ (${fig:op_constant}) carrega o valor de um literal para utilização por outra instrução. Recebe dois parâmetros: _valor_ e _próximo_, que representam o valor do literal a ser carregado e o código a ser executado a seguir. O valor recebido como _valor_ substitui o valor no registrador Acumulador e o valor em _próximo_ substitui o valor no registrador Code.

${do-fig:op_constant}

A instrução _LOOKUP_ (${fig:op_lookup}) carrega o valor de uma variável para o Acumulador. Recebe dois parâmetros: _nome_ e _próximo_, que representam o nome da variável a ser buscada e o código a ser executado a seguir. O valor recebido como _nome_ é utilizado para fazer a busca no escopo de variáveis atual e o valor encontrado é então carregado no registrador Acumulador; o valor armazenado em _próximo_ substitui o valor no registrador Code.

${do-fig:op_lookup}

A instrução _ASSIGN_ (${fig:op_assign}) substitui o valor de uma variável no escopo atual. Recebe dois parâmetros: _nome_, que representa o nome da variável, e _próximo_, que indica o código a ser executado após a execução da instrução atual. O valor da variável armazenada sob o vínculo indicado pelo conteúdo de _nome_ no escopo atual é substituído pelo valor no registrador Acumulador; caso não haja variável armazenada sob o nome indicado no escopo atual, um erro é sinalizado.  O valor em _próximo_ então substitui o valor no registrador Code.

${do-fig:op_assign}

A instrução _BIND_ (${fig:op_bind}) cria, no nível mais próximo do escopo atual, um novo vínculo de variável. Funciona de modo quase idêntico à instrução _ASSIGN_ recebendo os mesmos parâmetros, com a diferença que caso não haja variável armazenada sob o nome indicado, uma variável é criada para conter o valor.

${do-fig:op_bind}

A instrução _ARGUMENT_ (${fig:op_argument}) armazena na pilha do registrador Stack o valor atual do Acumulador. Recebe apenas o parâmetro indicando qual o próximo código a ser executado, que então é utilizado para setar o registrador Code.

${do-fig:op_argument}

A instrução _APPLY_ (${fig:op_apply}) inicia uma chamada a uma função ou primitiva e não recebe parâmetro algum. Utiliza como indicador de qual função ou primitiva a ser chamado o valor atual do Acumulador. 

${do-fig:op_apply}

Caso o valor no acumulador represente uma primitiva, a instrução simplesmente passa ao código da primtiiva a lista de parâmetros e mais nada. No entanto, se o valor no acumulador representar uma função ou closure definida pelo usuário um novo contexto de escopo baseado no valor dos argumentos e os parâmetros da função e substitui o valor do registrador Code pelo código da função em questão.

A instrução _RETURN_ (${fig:op_return}) restaura um frame anteriormente salvo pela instrução _FRAME_. Não recebe parâmetro algum e configura os valores dos registradores Stack, Environment, Code e Dump para os valores contidos no primeiro elemento da pilha armazenada no registrador Dump. Mantém o registrador Acumulador intacto.

${do-fig:op_return}

A instrução _REIFY_ (${fig:op_reify}) é utilizada para restaurar a computação ao ponto de uma continuação previamente obtida. Recebe como parâmetros _dump_ e _valor_, que representam, respectivamente, o conteúdo do registrador Dump no momento da criação da continuação e o valor a ser restaurado para o Acumulador quando a continuação for restaurada. O efeito final da instrução, é o de retornar ao ponto em que a continuação foi criada, restaurando os valores presentes no primeiro elemento da pilha em Dump, deixando _valor_ no acumulador.

${do-fig:op_reify}

A instrução _SAVE_ (${fig:op_save}) é responsável por criar uma referência para a continuação da computação atual. Com a arquitetura utilizada pela máquina virtual, uma continuação é simplesmente uma closure de apenas um parâmetro, contendo o valor atual do registrador Dump encapsulado, cujo único efeito é chamar a instrução _REIFY_ com parâmetros o valor do registrador Dump quando a continuação foi criada e o valor do único parâmetro da closure. Esta closure é então armazenada no Acumulador.

${do-fig:op_save}

A instrução _CLOSURE_ (${fig:op_closure}) cria uma nova closure, uma função em que o contexto na qual foi criada é acessível. Recebe como parâmetros _argumentos_, _corpo_ e _proximo_ que são, respectivamente, uma lista contendo os parâmetros formais da closure a ser criada, o código compilado do corpo da função e o código que deve ser executado ao fim desta instrução. A nova closure criada é armazenada no Acumulador e o registrador Code é configurado com o valor de _próximo_.

${do-fig:op_closure}

A instrução _BIND_MACRO_ é uma variante próxima da instrução _BIND_, usada apenas para mitigar uma deficiência do compilador: a falta de um mecanismo em tempo de compilação para gerenciar macros. Esta instrução recebe dois parâmetros (_nome_ e _proximo_) e espera que o acumulador contenha código para uma macro. Como resultado, guarda em um contexto geral de macros uma referência para o código da macro sob o nome recebido como _nome_ e substitui o valor em Code pelo valor de _proximo_.

A última instrução, _HALT_, simplesmente indica à máquina virtual que o processamento está terminado, e que o valor no Acumulador deve ser retornado como resultado da computação. Não recebe parâmetro algum, e não altera registrador algum.
